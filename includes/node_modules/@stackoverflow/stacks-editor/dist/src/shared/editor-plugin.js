import OrderedMap from "orderedmap";
/**
 * {@inheritDoc IExternalPluginProvider}
 * @internal
 */
export class ExternalPluginProvider {
    _plugins = {
        richText: [],
        commonmark: [],
    };
    _markdownProps = {
        parser: {},
        serializers: {
            nodes: {},
            marks: {},
        },
    };
    _nodeViews = {};
    /** {@inheritDoc IExternalPluginProvider.plugins} */
    get plugins() {
        return this._plugins;
    }
    /** {@inheritDoc IExternalPluginProvider.markdownProps} */
    get markdownProps() {
        return this._markdownProps;
    }
    /** {@inheritDoc IExternalPluginProvider.nodeViews} */
    get nodeViews() {
        return this._nodeViews;
    }
    menuCallbacks = [];
    schemaCallbacks = [];
    markdownItCallbacks = [];
    constructor(plugins, options) {
        if (plugins?.length) {
            for (const plugin of plugins) {
                this.applyConfig(plugin(options));
            }
        }
    }
    /** {@inheritDoc IExternalPluginProvider.getFinalizedSchema} */
    getFinalizedSchema(schema) {
        let alteredSchema = {
            nodes: OrderedMap.from(schema.nodes),
            marks: OrderedMap.from(schema.marks),
        };
        for (const callback of this.schemaCallbacks) {
            if (callback) {
                alteredSchema = callback(alteredSchema);
            }
        }
        return alteredSchema;
    }
    /** {@inheritDoc IExternalPluginProvider.alterMarkdownIt} */
    alterMarkdownIt(instance) {
        for (const callback of this.markdownItCallbacks) {
            if (callback) {
                callback(instance);
            }
        }
    }
    /** {@inheritDoc IExternalPluginProvider.getFinalizedMenu} */
    getFinalizedMenu(menu, schema) {
        //While we're working on the blocks, we need to be able to pull out entries by name easily
        let aggBlocks = {};
        // call each callback and aggregate the results
        for (const callback of [() => menu, ...this.menuCallbacks]) {
            if (!callback) {
                continue;
            }
            const blocks = callback(schema, menu);
            for (const block of blocks) {
                const existing = aggBlocks[block.name];
                if (existing) {
                    existing.entries = [...existing.entries, ...block.entries];
                    // set the priority to the lowest of existing and the newly aggregated block
                    existing.priority = Math.min(existing.priority || 0, block.priority || Infinity);
                }
                else {
                    aggBlocks = {
                        ...aggBlocks,
                        [block.name]: { ...block },
                    };
                }
            }
        }
        return Object.values(aggBlocks);
    }
    /** Applies the config of a single plugin to this provider */
    applyConfig(config) {
        config.commonmark?.plugins?.forEach((plugin) => {
            this._plugins.commonmark.push(plugin);
        });
        config.richText?.plugins?.forEach((plugin) => {
            this._plugins.richText.push(plugin);
        });
        this.schemaCallbacks.push(config.extendSchema);
        if (config.richText?.nodeViews) {
            this._nodeViews = {
                ...this._nodeViews,
                ...config.richText?.nodeViews,
            };
        }
        this.extendMarkdown(config.markdown, config.markdown?.alterMarkdownIt);
        this.menuCallbacks.push(config.menuItems);
    }
    /** Applies the markdownProps of a config to this provider */
    extendMarkdown(props, callback) {
        // TODO sanitize input to ensure nodes/marks for added parsers and vice versa?
        if (props?.parser) {
            this._markdownProps.parser = {
                ...this._markdownProps.parser,
                ...props.parser,
            };
        }
        if (props?.serializers?.nodes) {
            this._markdownProps.serializers.nodes = {
                ...this._markdownProps.serializers.nodes,
                ...props.serializers.nodes,
            };
        }
        if (props?.serializers?.marks) {
            this._markdownProps.serializers.marks = {
                ...this._markdownProps.serializers.marks,
                ...props.serializers.marks,
            };
        }
        if (callback) {
            this.markdownItCallbacks.push(callback);
        }
    }
}
