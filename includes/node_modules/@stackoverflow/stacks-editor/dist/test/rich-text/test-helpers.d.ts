import { MarkType, Node, Schema, Slice } from "prosemirror-model";
import { EditorState, Plugin, Transaction } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import { MenuCommand } from "../../src/shared/menu";
/** Consistent schema to test against */
export declare const testRichTextSchema: Schema<string, string>;
/**
 * Url to use when testing (de)serialization that contains special encodings/other pitfalls and
 * also goes the extra mile to conform to the more strict RFC3986
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc3986#section-2.2}
 */
export declare const crazyTestUrl: string;
/** Parses an html string into a ProseMirror node */
export declare function parseHtmlToDoc<T extends boolean>(htmlContent: string, asSlice: T): T extends true ? Slice : Node;
/** Creates a bare rich-text state with only the passed plugins enabled */
export declare function createState(htmlContent: string, plugins: Plugin[]): EditorState;
/** Creates a bare editor view with only the passed state and nothing else */
export declare function createView(state: EditorState): EditorView;
/** Applies a text selection to the passed state based on the given from/to */
export declare function applySelection(state: EditorState, from: number, to?: number): EditorState;
/** Creates a text selection transaction based on the given from/to */
export declare function setSelection(tr: Transaction, from: number, to?: number): Transaction;
/** Applies a node selection to the passed state based on the given from */
export declare function applyNodeSelection(state: EditorState, from: number): EditorState;
/** Creates a node selection transaction based on the given from */
export declare function setNodeSelection(tr: Transaction, from: number): Transaction;
/** Applies a command to the state and expects it to apply correctly */
export declare function runCommand(state: EditorState, command: MenuCommand, expectSuccess?: boolean): EditorState;
/** Sets up ProseMirror paste support globally for jsdom */
export declare function setupPasteSupport(): void;
/** Tears down ProseMirror paste support globally for jsdom */
export declare function cleanupPasteSupport(): void;
/** Sets up ProseMirror drop support globally for jsdom */
export declare function setupDropSupport(dropElement: HTMLElement): void;
/** Tears down ProseMirror drop support globally for jsdom */
export declare function cleanupDropSupport(): void;
/** Partial mock of DataTransfer for jsdom */
export declare class DataTransferMock implements DataTransfer {
    constructor(data: Record<string, string>, file?: File);
    private data;
    dropEffect: DataTransfer["dropEffect"];
    effectAllowed: DataTransfer["effectAllowed"];
    files: FileList;
    items: DataTransferItemList;
    get types(): string[];
    clearData(): void;
    getData(format: string): string;
    setData(format: string, data: string): void;
    setDragImage(): void;
}
/** Dispatches a paste event with the given records added to the clipboardData */
export declare function dispatchPasteEvent(el: Element, data: Record<string, string>, file?: File): ClipboardEvent;
/** Dispatches a paste event with the given records added to the clipboardData */
export declare function dispatchDropEvent(el: Element, file: File): DragEvent;
/** Returns a promise that is resolved delayMs from when it is called */
export declare function sleepAsync(delayMs: number): Promise<void>;
/**
 * Applies a command to the state and expects the entire doc to resemble
 * `expected` and the selected text to resemble `expectedSelected`
 */
export declare function executeTransaction(state: EditorState, command: (state: EditorState, dispatch: (tr: Transaction) => void) => boolean): {
    newState: EditorState;
    isValid: boolean;
};
/** Returns whether the selection range has a mark of the given type */
export declare function rangeHasMark(state: EditorState, from: number, to: number, markType: MarkType): boolean;
export declare const schemaWithSoftbreak: Schema<keyof import("orderedmap").default<import("prosemirror-model").NodeSpec>, keyof import("orderedmap").default<import("prosemirror-model").MarkSpec>>;
