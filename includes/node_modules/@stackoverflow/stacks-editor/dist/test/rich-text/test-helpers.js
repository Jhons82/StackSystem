import { DOMParser, Schema } from "prosemirror-model";
import { schema as basicSchema } from "prosemirror-schema-basic";
import { EditorState, NodeSelection, TextSelection, } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import { richTextSchemaSpec } from "../../src/rich-text/schema";
/** Consistent schema to test against */
export const testRichTextSchema = new Schema(richTextSchemaSpec);
/**
 * Url to use when testing (de)serialization that contains special encodings/other pitfalls and
 * also goes the extra mile to conform to the more strict RFC3986
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc3986#section-2.2}
 */
export const crazyTestUrl = `https://example.com/whatever?q=` +
    encodeURIComponent(`prefix:("+#some-zany_input.that,encodes~like*CRAZY?!_[don't@me&=send$$$]/);`).replace(/[-_.!~*'()]/g, (c) => `%${c.charCodeAt(0).toString(16)}`);
/** Parses an html string into a ProseMirror node */
export function parseHtmlToDoc(htmlContent, asSlice) {
    const container = document.createElement("div");
    // NOTE: tests only, no XSS danger
    // eslint-disable-next-line no-unsanitized/property
    container.innerHTML = htmlContent;
    const parser = DOMParser.fromSchema(testRichTextSchema);
    return asSlice ? parser.parseSlice(container) : parser.parse(container);
}
/** Creates a bare rich-text state with only the passed plugins enabled */
export function createState(htmlContent, plugins) {
    return EditorState.create({
        doc: parseHtmlToDoc(htmlContent, false),
        schema: testRichTextSchema,
        plugins: plugins,
    });
}
/** Creates a bare editor view with only the passed state and nothing else */
export function createView(state) {
    return new EditorView(document.createElement("div"), {
        state: state,
        plugins: [],
    });
}
/** Applies a text selection to the passed state based on the given from/to */
export function applySelection(state, from, to) {
    const tr = setSelection(state.tr, from, to);
    return state.apply(tr);
}
/** Creates a text selection transaction based on the given from/to */
export function setSelection(tr, from, to) {
    if (typeof to === "undefined") {
        to = from;
    }
    tr = tr.setSelection(TextSelection.create(tr.doc, from + 1, to + 1));
    return tr;
}
/** Applies a node selection to the passed state based on the given from */
export function applyNodeSelection(state, from) {
    const tr = setNodeSelection(state.tr, from);
    return state.apply(tr);
}
/** Creates a node selection transaction based on the given from */
export function setNodeSelection(tr, from) {
    tr = tr.setSelection(NodeSelection.create(tr.doc, from));
    return tr;
}
/** Applies a command to the state and expects it to apply correctly */
export function runCommand(state, command, expectSuccess = true) {
    let newState = state;
    const isValid = command(state, (t) => {
        newState = state.apply(t);
    });
    expect(isValid).toBe(expectSuccess);
    return newState;
}
/** Sets up ProseMirror paste support globally for jsdom */
export function setupPasteSupport() {
    Range.prototype.getClientRects = () => ({
        item: () => null,
        length: 0,
        [Symbol.iterator]: jest.fn(),
    });
    Range.prototype.getBoundingClientRect = () => jest.mocked({});
}
/** Tears down ProseMirror paste support globally for jsdom */
export function cleanupPasteSupport() {
    Range.prototype.getClientRects = undefined;
    Range.prototype.getBoundingClientRect = undefined;
}
/** Sets up ProseMirror drop support globally for jsdom */
export function setupDropSupport(dropElement) {
    Document.prototype.elementFromPoint = () => dropElement;
}
/** Tears down ProseMirror drop support globally for jsdom */
export function cleanupDropSupport() {
    Document.prototype.elementFromPoint = () => undefined;
}
/** Partial mock of DataTransfer for jsdom */
export class DataTransferMock {
    constructor(data, file) {
        this.data = data || {};
        if (file) {
            this.files = {
                0: file,
                item() {
                    return file;
                },
                length: 1,
                [Symbol.iterator]: jest.fn(),
            };
        }
    }
    data;
    dropEffect;
    effectAllowed;
    files;
    items;
    get types() {
        return Object.keys(this.data);
    }
    clearData() {
        throw new Error("Method not implemented.");
    }
    getData(format) {
        return this.data[format];
    }
    setData(format, data) {
        this.data[format] = data;
    }
    setDragImage() {
        throw new Error("Method not implemented.");
    }
}
/** Dispatches a paste event with the given records added to the clipboardData */
export function dispatchPasteEvent(el, data, file) {
    const event = new Event("paste");
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    event.clipboardData = new DataTransferMock(data, file);
    el.dispatchEvent(event);
    return event;
}
/** Dispatches a paste event with the given records added to the clipboardData */
export function dispatchDropEvent(el, file) {
    const event = new Event("drop");
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    event.dataTransfer = new DataTransferMock(null, file);
    el.dispatchEvent(event);
    return event;
}
/** Returns a promise that is resolved delayMs from when it is called */
export function sleepAsync(delayMs) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), delayMs);
    });
}
/**
 * Applies a command to the state and expects the entire doc to resemble
 * `expected` and the selected text to resemble `expectedSelected`
 */
export function executeTransaction(state, command) {
    let newState = state;
    const isValid = command(state, (t) => {
        newState = state.apply(t);
    });
    return { newState, isValid };
}
/** Returns whether the selection range has a mark of the given type */
export function rangeHasMark(state, from, to, markType) {
    let hasMark = false;
    state.doc.nodesBetween(from, to, (node) => {
        if (node.marks && node.marks.some((mark) => mark.type === markType)) {
            hasMark = true;
            return false;
        }
        return true;
    });
    return hasMark;
}
/** Extend prosemirror-schema-basic to add softbreak (to represent linebreaks coming from pasted Markdown) */
const extendedNodes = basicSchema.spec.nodes.addToEnd("softbreak", {
    inline: true,
    group: "inline",
    selectable: false,
    toDOM() {
        return ["br"];
    },
    parseDOM: [{ tag: "br" }],
});
const extendedMarks = basicSchema.spec.marks;
export const schemaWithSoftbreak = new Schema({
    nodes: extendedNodes,
    marks: extendedMarks,
});
